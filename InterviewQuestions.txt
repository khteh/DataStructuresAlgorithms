                root
			left	right
			
				0 (1 + max(1, 2)) = 1 + 2 = 3
			1 (1)	2 (1 + max(1, 0) = 2)
				  3 (1)
				  
	           0 (1 + min(1, 1)) = 1 + 1= 2
			1 (1)	2 (1 + min(1, 0) = 1)
				  3 (1)
				  
			Binary Tree:	  
				  50
			  -100   60 
			     0      100
			-50    10  75   150
			
			Binary Search Tree:
					50
				0			100
			-50	   10	75		150
		-100			60
		
MinHeap: (-100, -50, 0, 10, 50, 60 75, 100, 150)
					-100
				-50			0
			50		10	  60	100
		75  150
		
				10
			null		50
					60		100
0 - 99: 10 + 10 = 20
100 - 199: 2 * 20
200 - 299: 3 * 20 + 100 = 160
300 - 345: 5 + 10 = 15
total: 160 + 15 = 175

S: Single Responsibility
O: Open-Close
L: Liskov Substitution (Polymorphism)
I: Interface Segregation (Cohesive Interface)
D: Dependency Inversion (Abstraction/Interface. Not details)

0: N
1: N-1
2: N-2

0 - 4
0 - 1, 3 - 4

1 2 9
4 5 6
2 8 9

1 2 9 7
4 5 6 8
2 8 9 9

1(path1:6; path2: 7)				2 (path1=Long.Min; path2=[n][n](4)
  returns 1 + 7								returns 2 + 4

3 (path1:[n][n](4); path2: Long.Min) 4 returns 4 (value of this location)
  returns 3 + 4

1 3 5
2 4 6
7 8 9

22 (1,2,4,6,9)
23 (1,3,4,6,9)
24 (1,3,5,6,9) (1,2,4,8,9)
25 (1,3,4,8,9)
27 (1,2,7,8,9)

N: sum
N-1: sum - f(N)
N-2: sum - f(N-1)

						1
					2		4
				9	    5	   2
				    6       8
					    9

						1
					2		4
				9	    5	   2
			7	    6       8
				8	    9
					9
					
Minute arm:
min /60 * 360

Hours arm:
hour / 12 * 360 + n
n: 60 min -> 1/12 * 360
   m	  -> m/60 * 1/12 * 360

Angle between minute and hour hands:
h/12 * 360 + m/60 * 1/12 * 360 - m/60 * 360
= 360 * (h/12 + m/60 * 1/12 - m/60)
= 360 * (h/12 + m/60( 1/12 - 1))
= 360 * (h/12 - m/60 * 11/12)

